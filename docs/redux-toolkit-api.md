# Redux Toolkit API

## createAction

기존의 리덕스에서는 액션 타입을 지정하고 액션 생성자 함수를 통해서 액션을 생성해서 사용하였다. 하지만 리덕스 툴킷에서는 액션 타입과 액션 생성자를 따로 만들지 않고 `createAction`이라는 함수를 통해서 한 번에 해결한다.

```js
// ✅ Before
// 1) action
const PLUS = 'counter/PLUS';
const MINUS = 'counter/MINUS';
// 2) action craetor
export const plus = () => ({ type: PLUS });
export const minus = () => ({ type: MINUS });

// ✅ After
// using redux toolkit
export const plus = createAction('counter/PLUS');
export const minus = createAction('counter/MINUS');

/*
call plus()

→ return value
{
  type : "counter/PLUS",
  payload : undefined
}
*/
```

위 코드처럼 createAction를 통해서 반환된 값은 액션 생성자 함수이다. 상태 변경이 필요한 컴퍼넌트에서 해당 함수를 임포트하여 호출하면 액션이 생성되고 그 액션을 dispatch하면 기존 리덕스 흐름과 같이 상태를 변경시킬 수 있게 된다. 주석에 적어놨듯이 액션 생성자 함수는 항상 같은 형태의 액션을 반환한다. createAction에 들어가는 인자는 항상 액션의 type이 되고, 액션 생성자 함수를 실행할 때 들어가는 인자는 리덕스에 전달하는 값이 된다. payload라는 키는 정해진 값으로 전달하려는 값은 항상 payload에 할당된다. 만약에 payload를 커스터마이징하고 싶다면, createAction의 두번째 인자로 콜백 함수를 넣어주면 된다.

```js
export const plus = createAction('counter/PLUS', (number) => {
  return {
    payload: {
      date: new Date(),
      count: number,
    },
  };
});

// use
dispatch(plus(3));

/*
→ plus(3) return value
{
  type : "counter/PLUS",
  payload : {
    date: 1642845043429,
    count : 3
  }
}
*/
```

## createReducer

기존의 리듀서의 단점을 보완하고자 툴킷에서는 createReducer라는 API를 제공한다. 그렇다면 기존에 어떠한 불편한 점이 있었고, createReducer에서는 이를 어떻게 극복했는지 알아보자.

- 문제1) 불변성 지키기

  상태의 불변성을 지키기 위해서 항상 새로운 상태를 만들어줘야만 했고, 그 방식으로 리터럴 방식을 주로 사용하였다. 중첩객체, 중중중...첩 객체에서 불변성을 지켜줘야하는 경우들이 생기면서 매우 가독성이 안좋아지고, 코드를 구현하는 것이 어려워지는 상황이 발생하기도 하였다. 그래서 [immer](https://immerjs.github.io/immer/)라는 라이브러리를 통해서 좀 더 쉽게 불변객체를 유지할 수 있게 되었다. 하지만 immer를 다시 설치해주는 번거로움이 생기는 것은 당연지사였다. 그런데 createReducer에서는 `immer가 자체 내장`되어 있어서 좀 더 쉽게 리듀서를 구현할 수 있게 되었다.

- 문제2) switch-case문을 통한 구현

  일반적으로 리듀서는 switch-case문과 action.type의 문자열 관계를 기반으로 구현한다. 이 과정에서 문자열의 오타 혹은 default case를 빼먹거나 initial state를 빼먹어서 오류를 발생하는 경우가 있다. 이러한 `error-prone`(오류가 발생하기 쉬운) 구조를 벗어나기 위해서 createReducer에선 action을 핸들링하는데 있어서 2가지 패턴을 제시하였다. 1) `builder callback` 방식, 2) `map object` 방식이다. 해당 방식들에 대해선 코드를 통해서 알아보자.

  > map object 방식은 자바스크립트에서만 사용이 가능하고(타입스크립트에서는 사용 못함ㅠ), IDE에서 지원을 안하는 경우가 있어서 주로 builder callback 방식을 추천한다.

  ```js
  export const counterReducer = createReducer(initialState, (builder) => {
    builder
      .addCase(plus, (state, action) => {
        state.count++;
      })
      .addCase(minus, (state, action) => {
        state.count--;
      })
      .addDefaultCase((state, action) => {});
  });
  ```

  createReducer의 첫번째 인자로는 초기상태가 들어오고, 두번째 인자로 무엇이 들어오냐에 따라서 방식이 나뉜다. 위 코드는 `builder callback`이 들어오는 방식이다.

  builder 객체는 3가지 메소드를 제공한다. 3가지 메소드를 메소드 체이닝으로 조합하여 리듀서를 구현한다. 이로 인해 코드를 좀 더 간결하고 가독성 높게 구현할 수 있게 된다.

  - addCase(actionCreator, reducer)

    > actionCreator : string | function generated by createAction()

    > reducer : function

    특정 action type에 따른 리듀서를 구현할 때 사용한다. 주의할 점은 addCase의 경우, addMatcher, addDefaultCase 보다 먼저 구현되어 있어야한다.(쉽게 위에 구현되어야한다.)

  - addMatcher(matcher, reducer)

    > matcher : function

    > reducer : function

    여러 액션을 통합해서 그룹지을때, 사용한다. 예를 들어서 API통신시 pending상태에서의 상태변화가 모두 같다면, `(action) => action.type.endsWith('pending')` 와 같은 match 함수를 구현하여서 사용할 수 있다.

  - addDefaultCase(reducer)

    > reducer : function

    switch-case문에서의 default case에 해당하는 경우, addDefaultCase를 사용하여 구현할 수 있다. addCase와 addMatcher에서 걸러지지 않는다면 addDefaultCase가 실행된다.

  ```js
  export const counterReducer = createReducer(initialState, {
    [plus]: (state, action) => {
      state.count++;
    },
    [minus]: (state, action) => {
      state.count--;
    },
  });
  ```

  위 코드는 두번째 방식인 Map Object 방식이다. 이 방식으로 사용할 때는 createReducer에 4가지 인자가 들어갈 수 있다.

  - initialState

    초기 상태값

  - actionsMap

    액션 타입이 리듀서와 맵핑되어 있는 객체로서 일반적으로 switch-case문에서 봐왔던 방식과 유사하다.(객체로 표현한다는 점만 다를뿐). 객체로 표현하기 위해서 키값을 주어야한다. 이 때 사용하는 키값이 createAction에서 생성된 생성자 함수로서 객체에 키를 동적 할당할 수 있는 문법인 `[ ]`를 통해서 구현한다.
    (예전 방식처럼 액션 타입 문자열을 통해서 구현할 수도 있다.)

  - actionMatchers

    `[ { matcher : function, reducer : function}, ... ]` 의 형태로서 matcher에 해당하는 타입이 실행된다.

  - defaultCaseReducer

    기본 리듀서 함수로서 앞선 리듀서가 실행되지않는다면, 기본 케이스 리듀서가 실행된다.

### How to mutate state with error message

> 에러 메세지를 통해서 알아보는 리덕스 툴 킷에서 상태 변경 방식

앞서 말했듯이 createReducer에서는 자체적으로 이머를 제공하기 때문에 상태를 변경할 때, `mutating version(상태 직접 변경)`으로도 가능하다.(반환값이 없다.) 뿐만 아니라 새로운 상태를 만들어서 반환하는 방식(반환값이 있다.), immutable를 지키는 방식으로도 아무런 문제 없이 가능하다. 하지만 이 둘을 혼합하여 사용하면 문제가 생긴다.

```js
(state, action) => state.count++;
```

위와 같은 리듀서를 만들면 아래와 같은 에러 메세지를 접할 수 있다.

```
[Immer] An immer producer returned a new value *and* modified its draft. Either return a new value *or* modify the draft.
```

이는 새로운 상태를 리턴하거나 상태를 직접 수정하는 방법, 둘 중에 한가지 방법을 사용하는 것이 아니라 모두 사용하려고 했기 때문에 나타난 오류이다.

코드를 좀 설명하자면, 화살표 함수 `() => ()` 로 표현하면 화살표 다음 `( )`가 리턴값이 된다. 이렇게 표현하고 싶다면, 새로운 상태를 반환하는 방법만 사용해야한다. 하지만 위 코드는 상태를 직접 변경하면서 리턴값도 주기 때문에 두가지를 혼용했다는 에러가 뜨는 것이다.

## configureStore

기존에 리덕스 스토어를 설정할 때, 리덕스를 좀 더 잘, 쉽게 사용하기 위해선 생각보다 많은 추가적인 미들웨어를 설치해야만 했다. 이러한 불편함을 없애기 위해서 기존의 createStore에 기능을 추가하고 추상화한 버전이 리덕스 툴킷의 `configureStore`이다.

configureStore는 인자로 `옵션 객체`가 들어간다. 옵션에는 `4개의 속성`이 있는데, 그 중에서 <u>reducer만 필수요소</u>이고 나머지는 선택옵션이다. 해당 옵션들에 대해서 알아보자.

- reducer

  하나의 `rootReducer`를 설정한다. 일반적으로 여러 개의 리듀서를 사용하는 경우 combineReducers를 통해서 리듀서를 합쳐서 하나의 rootReducer로 설정한다.

- middleware

  리덕스 미들웨어를 담은 배열로서 해당 옵션을 설정하지 않으면, `getDefaultMiddleware()` 의해서 반환되는 미들웨어, 즉 기본 미들웨어가 설치된다. 기본 미들웨어는 아래와 같다.

  ```js
  // development
  const middleware = [thunk, immutableStateInvariant, serializableStateInvariant];

  // product
  const middleware = [thunk];
  ```

  > thunk는 리덕스에서 비동기 작업을 위한 미들웨어

  > immutableStateInvariant는 상태 변형을 감지하는 미들웨어

  > serializableStateInvariant는 직렬화(serialize : 데이터를 다른 데이터에 맞춰 가공하는 행위)가 불가능한 값(Promise, Symbol, Map/Set, function, class instance 등)이 state나 action에 감지되면 경고해주는 미들웨어

- devTools

  기본적으로 불리언 값으로 설정하나 객체로 설정하는 경우, devTools에 추가적인 옵션을 설정할 수 있다. 해당 옵션의 기본값은 `true`로, 이 경우, `Redux DevTools browser extension`을 자동으로 제공하게 된다.

  > Redux DevTools browser extension은 리덕스의 액션 스택의 추적을 용이하게 해주는 확장 프로그램이다. 뿐만 아니라 상태 비교/대조를 통해서 상태 관리를 좀 더 직관적이고 쉽게 할 수 있게 도와준다.

- preloadedState

  스토어의 추가적인 초기값을 설정하는 옵션이다.

- enhancers

  enhancer(기능을 증진시키는 것)라는 의미처럼 추가적으로 리덕스 스토어의 성능을 향상시키기 위한 설정이다. enhancers를 담은 배열이나 콜백함수를 통해서 커스터마이징 할 수 있다. enhancers를 어떻게 만드냐에 따라서 적용되는 순서가 달라진다.

  - 배열

    ```js
      {
        middleware,
        devTools : true,
        enhancers : [offline]
      }

      // 실제 최종 적용 결과
      // [ ...middleware, offline, devToolsExtension]
    ```

  - 콜백함수

    ```js
      {
        middleware,
        devTools : true,
        enhancers : (defaultEnhancers) => [offline, ...defaultEnhancers]
      }

      // 실제 최종 적용 결과
      // [offline, ...middleware, devToolsExtension]
    ```

    > 만약에 인핸서를 미들웨어보다 먼저 적용하고 싶은 경우, 콜백을 이용할 수 있다.

- configureStore을 이용한 스토어 설정 전체 코드

  ```js
  import { configureStore } from '@reduxjs/toolkit';
  import { combineReducers } from 'redux';
  import logger from 'redux-logger';
  import authReducer from './reducers/auth';
  import postsReducer from './reducers/posts';
  import { reduxBatch } from '@manaflair/redux-batch';

  const rootReducer = combineReducers({
    auth: authReducer,
    posts: postsReducer,
  });

  export const configure = () =>
    configureStore({
      reducer: rootReducer,
      middleware: (getDefaultMiddleware) => getDefaultMiddleware().concat(logger),
      devTools: process.env.NODE_ENV !== 'production',
      enhancers: [reduxBatch], //enhancers 예시
    });
  ```

## createSlice

## createAsyncThunk

## createSelector
