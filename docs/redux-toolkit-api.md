# Redux Toolkit API

## createAction

기존의 리덕스에서는 액션 타입을 지정하고 액션 생성 함수를 통해서 액션을 생성해서 사용하였다. 하지만 리덕스 툴킷에서는 액션 타입과 액션 생성 함수를 따로 만들지 않고 `createAction`이라는 함수를 통해서 한 번에 해결한다.

```js
// ✅ Before
// 1) action
const PLUS = 'counter/PLUS';
const MINUS = 'counter/MINUS';
// 2) action craetor
export const plus = () => ({ type: PLUS });
export const minus = () => ({ type: MINUS });

// ✅ After
// using redux toolkit
export const plus = createAction('counter/PLUS');
export const minus = createAction('counter/MINUS');

/*
call plus()

→ return value
{
  type : "counter/PLUS",
  payload : undefined
}
*/
```

위 코드처럼 createAction를 통해서 반환된 값은 액션 생성 함수이다. 상태 변경이 필요한 컴퍼넌트에서 해당 함수를 임포트하여 호출하면 액션이 생성되고 그 액션을 dispatch하면 기존 리덕스 흐름과 같이 상태를 변경시킬 수 있게 된다. 주석에 적어놨듯이 액션 생성 함수는 항상 같은 형태의 액션을 반환한다. createAction에 들어가는 인자는 항상 액션의 type이 되고, 액션 생성 함수를 실행할 때 들어가는 인자는 리덕스에 전달하는 값이 된다. payload라는 키는 정해진 값으로 전달하려는 값은 항상 payload에 할당된다. 만약에 payload를 커스터마이징하고 싶다면, createAction의 두번째 인자로 콜백 함수를 넣어주면 된다.

```js
export const plus = createAction('counter/PLUS', (number) => {
  return {
    payload: {
      date: new Date(),
      count: number,
    },
  };
});

// use
dispatch(plus(3));

/*
→ plus(3) return value
{
  type : "counter/PLUS",
  payload : {
    date: 1642845043429,
    count : 3
  }
}
*/
```

## createReducer

기존의 리듀서의 단점을 보완하고자 툴킷에서는 createReducer라는 API를 제공한다. 그렇다면 기존에 어떠한 불편한 점이 있었고, createReducer에서는 이를 어떻게 극복했는지 알아보자.

- 문제1) 불변성 지키기

  상태의 불변성을 지키기 위해서 항상 새로운 상태를 만들어줘야만 했고, 그 방식으로 리터럴 방식을 주로 사용하였다. 중첩객체, 중중중...첩 객체에서 불변성을 지켜줘야하는 경우들이 생기면서 매우 가독성이 안좋아지고, 코드를 구현하는 것이 어려워지는 상황이 발생하기도 하였다. 그래서 [immer](https://immerjs.github.io/immer/)라는 라이브러리를 통해서 좀 더 쉽게 불변객체를 유지할 수 있게 되었다. 하지만 immer를 다시 설치해주는 번거로움이 생기는 것은 당연지사였다. 그런데 createReducer에서는 `immer가 자체 내장`되어 있어서 좀 더 쉽게 리듀서를 구현할 수 있게 되었다.

- 문제2) switch-case문을 통한 구현

  일반적으로 리듀서는 switch-case문과 action.type의 문자열 관계를 기반으로 구현한다. 이 과정에서 문자열의 오타 혹은 default case를 빼먹거나 initial state를 빼먹어서 오류를 발생하는 경우가 있다. 이러한 `error-prone`(오류가 발생하기 쉬운) 구조를 벗어나기 위해서 createReducer에선 action을 핸들링하는데 있어서 2가지 패턴을 제시하였다. 1) `builder callback` 방식, 2) `map object` 방식이다. 해당 방식들에 대해선 코드를 통해서 알아보자.

  > map object 방식은 자바스크립트에서만 사용이 가능하고(타입스크립트에서는 사용 못함ㅠ), IDE에서 지원을 안하는 경우가 있어서 주로 builder callback 방식을 추천한다.

  ```js
  export const counterReducer = createReducer(initialState, (builder) => {
    builder
      .addCase(plus, (state, action) => {
        state.count++;
      })
      .addCase(minus, (state, action) => {
        state.count--;
      })
      .addDefaultCase((state, action) => {});
  });
  ```

  createReducer의 첫번째 인자로는 초기상태가 들어오고, 두번째 인자로 무엇이 들어오냐에 따라서 방식이 나뉜다. 위 코드는 `builder callback`이 들어오는 방식이다.

  builder 객체는 3가지 메소드를 제공한다. 3가지 메소드를 메소드 체이닝으로 조합하여 리듀서를 구현한다. 이로 인해 코드를 좀 더 간결하고 가독성 높게 구현할 수 있게 된다.

  - addCase(actionCreator, reducer)

    > actionCreator : string | function generated by createAction()

    > reducer : function

    특정 action type에 따른 리듀서를 구현할 때 사용한다. 주의할 점은 addCase의 경우, addMatcher, addDefaultCase 보다 먼저 구현되어 있어야한다.(쉽게 위에 구현되어야한다.)

  - addMatcher(matcher, reducer)

    > matcher : function

    > reducer : function

    여러 액션을 통합해서 그룹지을때, 사용한다. 예를 들어서 API통신시 pending상태에서의 상태변화가 모두 같다면, `(action) => action.type.endsWith('pending')` 와 같은 match 함수를 구현하여서 사용할 수 있다.

  - addDefaultCase(reducer)

    > reducer : function

    switch-case문에서의 default case에 해당하는 경우, addDefaultCase를 사용하여 구현할 수 있다. addCase와 addMatcher에서 걸러지지 않는다면 addDefaultCase가 실행된다.

  ```js
  export const counterReducer = createReducer(initialState, {
    [plus]: (state, action) => {
      state.count++;
    },
    [minus]: (state, action) => {
      state.count--;
    },
  });
  ```

  위 코드는 두번째 방식인 Map Object 방식이다. 이 방식으로 사용할 때는 createReducer에 4가지 인자가 들어갈 수 있다.

  - initialState

    초기 상태값

  - actionsMap

    액션 타입이 리듀서와 맵핑되어 있는 객체로서 일반적으로 switch-case문에서 봐왔던 방식과 유사하다.(객체로 표현한다는 점만 다를뿐). 객체로 표현하기 위해서 키값을 주어야한다. 이 때 사용하는 키값이 createAction에서 생성된 액션 생성 함수로서 객체에 키를 동적 할당할 수 있는 문법인 `[ ]`를 통해서 구현한다.
    (예전 방식처럼 액션 타입 문자열을 통해서 구현할 수도 있다.)

  - actionMatchers

    `[ { matcher : function, reducer : function}, ... ]` 의 형태로서 matcher에 해당하는 타입이 실행된다.

  - defaultCaseReducer

    기본 리듀서 함수로서 앞선 리듀서가 실행되지않는다면, 기본 케이스 리듀서가 실행된다.

### How to mutate state with error message

> 에러 메세지를 통해서 알아보는 리덕스 툴 킷에서 상태 변경 방식

앞서 말했듯이 createReducer에서는 자체적으로 이머를 제공하기 때문에 상태를 변경할 때, `mutating version(상태 직접 변경)`으로도 가능하다.(반환값이 없다.) 뿐만 아니라 새로운 상태를 만들어서 반환하는 방식(반환값이 있다.), immutable를 지키는 방식으로도 아무런 문제 없이 가능하다. 하지만 이 둘을 혼합하여 사용하면 문제가 생긴다.

```js
(state, action) => state.count++;
```

위와 같은 리듀서를 만들면 아래와 같은 에러 메세지를 접할 수 있다.

```
[Immer] An immer producer returned a new value *and* modified its draft. Either return a new value *or* modify the draft.
```

이는 새로운 상태를 리턴하거나 상태를 직접 수정하는 방법, 둘 중에 한가지 방법을 사용하는 것이 아니라 모두 사용하려고 했기 때문에 나타난 오류이다.

코드를 좀 설명하자면, 화살표 함수 `() => ()` 로 표현하면 화살표 다음 `( )`가 리턴값이 된다. 이렇게 표현하고 싶다면, 새로운 상태를 반환하는 방법만 사용해야한다. 하지만 위 코드는 상태를 직접 변경하면서 리턴값도 주기 때문에 두가지를 혼용했다는 에러가 뜨는 것이다.

## configureStore

기존에 리덕스 스토어를 설정할 때, 리덕스를 좀 더 잘, 쉽게 사용하기 위해선 생각보다 많은 추가적인 미들웨어를 설치해야만 했다. 이러한 불편함을 없애기 위해서 기존의 createStore에 기능을 추가하고 추상화한 버전이 리덕스 툴킷의 `configureStore`이다.

configureStore는 인자로 `옵션 객체`가 들어간다. 옵션에는 `4개의 속성`이 있는데, 그 중에서 <u>reducer만 필수요소</u>이고 나머지는 선택옵션이다. 해당 옵션들에 대해서 알아보자.

- reducer

  하나의 `rootReducer`를 설정한다. 일반적으로 여러 개의 리듀서를 사용하는 경우 combineReducers를 통해서 리듀서를 합쳐서 하나의 rootReducer로 설정한다.

- middleware

  리덕스 미들웨어를 담은 배열로서 해당 옵션을 설정하지 않으면, `getDefaultMiddleware()` 의해서 반환되는 미들웨어, 즉 기본 미들웨어가 설치된다. 기본 미들웨어는 아래와 같다.

  ```js
  // development
  const middleware = [thunk, immutableStateInvariant, serializableStateInvariant];

  // product
  const middleware = [thunk];
  ```

  > thunk는 리덕스에서 비동기 작업을 위한 미들웨어

  > immutableStateInvariant는 상태 변형을 감지하는 미들웨어

  > serializableStateInvariant는 직렬화(serialize : 데이터를 다른 데이터에 맞춰 가공하는 행위)가 불가능한 값(Promise, Symbol, Map/Set, function, class instance 등)이 state나 action에 감지되면 경고해주는 미들웨어

- devTools

  기본적으로 불리언 값으로 설정하나 객체로 설정하는 경우, devTools에 추가적인 옵션을 설정할 수 있다. 해당 옵션의 기본값은 `true`로, 이 경우, `Redux DevTools browser extension`을 자동으로 제공하게 된다.

  > Redux DevTools browser extension은 리덕스의 액션 스택의 추적을 용이하게 해주는 확장 프로그램이다. 뿐만 아니라 상태 비교/대조를 통해서 상태 관리를 좀 더 직관적이고 쉽게 할 수 있게 도와준다.

- preloadedState

  스토어의 추가적인 초기값을 설정하는 옵션이다.

- enhancers

  enhancer(기능을 증진시키는 것)라는 의미처럼 추가적으로 리덕스 스토어의 성능을 향상시키기 위한 설정이다. enhancers를 담은 배열이나 콜백함수를 통해서 커스터마이징 할 수 있다. enhancers를 어떻게 만드냐에 따라서 적용되는 순서가 달라진다.

  - 배열

    ```js
      {
        middleware,
        devTools : true,
        enhancers : [offline]
      }

      // 실제 최종 적용 결과
      // [ ...middleware, offline, devToolsExtension]
    ```

  - 콜백함수

    ```js
      {
        middleware,
        devTools : true,
        enhancers : (defaultEnhancers) => [offline, ...defaultEnhancers]
      }

      // 실제 최종 적용 결과
      // [offline, ...middleware, devToolsExtension]
    ```

    > 만약에 인핸서를 미들웨어보다 먼저 적용하고 싶은 경우, 콜백을 이용할 수 있다.

- configureStore을 이용한 스토어 설정 전체 코드

  ```js
  import { configureStore } from '@reduxjs/toolkit';
  import { combineReducers } from 'redux';
  import logger from 'redux-logger';
  import authReducer from './reducers/auth';
  import postsReducer from './reducers/posts';
  import { reduxBatch } from '@manaflair/redux-batch';

  const rootReducer = combineReducers({
    auth: authReducer,
    posts: postsReducer,
  });

  export const configure = () =>
    configureStore({
      reducer: rootReducer,
      middleware: (getDefaultMiddleware) => getDefaultMiddleware().concat(logger),
      devTools: process.env.NODE_ENV !== 'production',
      enhancers: [reduxBatch], //enhancers 예시
    });
  ```

## createSlice

리덕스 툴킷을 사용하는 이유는 바로 `createSlice`에 있다고 해도 과언이 아니다. createSlice는 앞서 설명한 createAction과 createReducer를 합쳐서 추상화시킨 것이라고 생각하면 된다. 그렇기 때문에 createSlice를 이용하면 리덕스 데이터 흐름의 모든 것을 구현할 수 있다. createSlice의 패턴을 알아보자.

```js
const slicer = createSlice({
  name: 'counter',
  initialState: initialState,
  reducers: {
    add: (state) => state + 1,
  },
  extraReducers: {},
});

console.log(slicer);
/*
    {
      name : string,
      reducer : ReducerFunction,
      actions : Record<string, ActionCreator>,
      caseReducers: Record<string, CaseReducer>.
      getInitialState: () => State
    }
  */
```

createSlice는 option 객체를 인자로 받는다. 객체의 속성으로 아래에 있는 4가지를 넣을 수 있다.

- name

  slicer의 이름을 지정한다. 이 이름에 따라서 아래 reducer에서 만들어지는 액션 타입의 네임스페이스가 달라진다. (action type의 prefix에 해당한다.)

- initialState

  상태 초기값 설정

- reducers

  각각의 액션 타입에 따른 리듀서를 객체 안에 메소드 형태로 만들 수 있다. 위 코드를 살펴보자. reducers 객체 안에 `add: (state) => state + 1` 메소드가 있다. 여기서 add라는 키값에 의해서 매칭되는 액션 타입이 자동으로 만들어진다.(내부적으로 createAction이 작동하여, add라는 액션 생성 함수가 만들어진다.) 액션 타입은 앞에서 설정한 name 속성과 키값이 합쳐져서 `counter/add` 라는 문자열로 설정된다.

  리듀서에서 작동하는 흐름을 보면, 위에서 만들어진 액션 타입에 맞는 액션이 디스패치되면 이에 상응하는 리듀서가 실행하여 상태를 변경한다.

- extraReducers

  reducers 속성 말고도 extraReducers이 존재하는 이유는 뭔지 생각해보자. 또한 두가지 리듀서가 어떤 부분이 다른지를 생각해보자.
  reducers 속성은 리덕스의 동기적인 데이터 흐름, 즉, 내부에서 이루어지는 상태 변경에 대한 관리을 책임진다. 이에 반해 extraReducers는 외부에서의 리덕스의 동기적 흐름외에 비동기적 흐름이 필요한 경우 해당 리듀서를 사용할 수 있다. 예를 들어 외부와의 통신을 들 수 있다. 또한 createReducer에서 처럼 2가지 방법으로 표현할 수 있다. builder callback과 map object 방식. 여기서도 물론 builder callback 방식을 추천한다.

  ```js
  const isPendingAction = (action) => action.type.endsWith('pending');
  const isRejectedAction = (action) => action.type.endsWith('rejected');

  {
    //...
    extraReducers: (builder) => {
      builder
        .addCase('posts/getPosts/fufilled', (state, action) => {
          state.data = action.payload;
        })
        .addCase('posts/addPost/fufilled', (state, action) => {
          state.message = 'Created';
        })
        .addMatcher(isRejectedAction, (state, action) => {
          state.error = action.error;
        })
        .addMatcher(isPendingAction, (state, action) => {
          //....
        })
        .addDefaultCase((state, action) => {
          return state;
        });
    };
  }
  ```

  > 앞서 배운 createReducer와 유사한 형태를 가지고 있다. 단, 다른 점은 액션 타입 문자열에 끝에 외부 통신의 상태를 말해주는 키워드가 붙어있다는 것이다. 이 부분은 아래 `createAsyncThunk`에서 다룰 예정이다. 통신 상태는 pending(로딩), fufilled(성공), rejected(실패) 이 3가지의 상태를 가지고 있고 이에 따라서 액션 타입이 만들어지고 이에 상응하는 로직을 구현해야한다.

## createAsyncThunk

기존에 thunk를 바탕으로 만들어진 함수이다. 즉 비동기 작업 처리를 위한 함수이다. 함수는 2가지 인자를 받는다. 첫번째 인자는 액션 타입 문자열, 두번째 인자는 프로미스를 반환하는 콜백함수 이다. createAsyncThunk는 첫번째 인자로 받은 문자열을 바탕으로 프로미스 요청에 대한 라이프 사이클(3가지 상태)의 액션 타입을 만들고, thunk action creator(thunk 액션 생성 함수)를 반환한다. thunk action creator는 프로미스 콜백을 실행하고 프로미스 요청에 따른 라이프 사이클 액션을 디스패칭한다.

예를 들어서 아래는 외부 통신을 통해서 모든 포스트를 가져오는 요청에 대한 코드이다.

```js
export const getPosts = createAsyncThunk('posts/getPosts', async () => {
  const response = await postsAPI.getPosts();
  return response.data;
});
```

getPosts에는 3종류의 thunk action creator를 담고 있다. `posts/getPosts/pending` 액션을 디스패칭하는 thunk action creator, `posts/getPosts/fufilled` 액션을 디스패칭하는 thunk action creator, `posts/getPosts/rejected` 액션을 디스패칭하는 thunk action creator. 각각의 pending, fufilled,rejected 라는 키 값으로 접근할 수 있다.

thunk action creator가 동작하는 과정을 살펴보자. 먼저 pending 액션이 디스패칭된다. 프로미스 콜백(createAsyncThunk에서 두번째 인자로 들어간 콜백을 말한다.)이 실행되고 콜백의 리턴값을 기다린다. 이 경우 상태에 따라서 2가지 경우로 나뉠 수 있다. 정상적인 통신을 통해서 처리가 되었다면, fufilled 액션과 action.payload에 리턴값을 담아서 디스패칭된다. 하지만 정상적인 통신이 이루어지지 않았다면(통신이 거절된 경우/에러가 일어나는 경우), rejected 액션과 에러메시지를 담아서 디스패칭된다. 디스패칭된 액션은 리듀서로 전달된다. 이 때 액션 타입에 맞는 로직을 (위에서 설명한) `createSlice의 extraReducer`에서 찾아서 실행하게 된다. 즉 createAsyncThunk는 createSlice의 extraReducer 속성 안에서 함께 사용하게 된다. 또한 addCase의 첫번째 인자로 `posts/getPosts/fufilled` 문자열 대신 action creator를 사용할 수 있기에 아래와 같이 표현할 수 있다.

```js
// before
addCase('posts/getPosts/fufilled', (state, action) => {
  //...
});

// after
addCase(getPosts.fufilled, (state, action) => {
  //...
});
```

## createSelector
