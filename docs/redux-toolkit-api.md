# Redux Toolkit API

## createAction

기존의 리덕스에서는 액션 타입을 지정하고 액션 생성자 함수를 통해서 액션을 생성해서 사용하였다. 하지만 리덕스 툴킷에서는 액션 타입과 액션 생성자를 따로 만들지 않고 `createAction`이라는 함수를 통해서 한 번에 해결한다.

```js
// ✅ Before
// 1) action
const PLUS = 'counter/PLUS';
const MINUS = 'counter/MINUS';
// 2) action craetor
export const plus = () => ({ type: PLUS });
export const minus = () => ({ type: MINUS });

// ✅ After
// using redux toolkit
export const plus = createAction('counter/PLUS');
export const minus = createAction('counter/MINUS');

/*
call plus()

→ return value
{
  type : "counter/PLUS",
  payload : undefined
}
*/
```

위 코드처럼 createAction를 통해서 반환된 값은 액션 생성자 함수이다. 상태 변경이 필요한 컴퍼넌트에서 해당 함수를 임포트하여 호출하면 액션이 생성되고 그 액션을 dispatch하면 기존 리덕스 흐름과 같이 상태를 변경시킬 수 있게 된다. 주석에 적어놨듯이 액션 생성자 함수는 항상 같은 형태의 액션을 반환한다. createAction에 들어가는 인자는 항상 액션의 type이 되고, 액션 생성자 함수를 실행할 때 들어가는 인자는 리덕스에 전달하는 값이 된다. payload라는 키는 정해진 값으로 전달하려는 값은 항상 payload에 할당된다. 만약에 payload를 커스터마이징하고 싶다면, createAction의 두번째 인자로 콜백 함수를 넣어주면 된다.

```js
export const plus = createAction('counter/PLUS', (number) => {
  return {
    payload: {
      date: new Date(),
      count: number,
    },
  };
});

// use
dispatch(plus(3));

/*
→ plus(3) return value
{
  type : "counter/PLUS",
  payload : {
    date: 1642845043429,
    count : 3
  }
}
*/
```

## createReducer

기존의 리듀서의 단점을 보완하고자 툴킷에서는 createReducer라는 API를 제공한다. 그렇다면 기존에 어떠한 불편한 점이 있었고, createReducer에서는 이를 어떻게 극복했는지 알아보자.

- 문제1) 불변성 지키기

  상태의 불변성을 지키기 위해서 항상 새로운 상태를 만들어줘야만 했고, 그 방식으로 리터럴 방식을 주로 사용하였다. 중첩객체, 중중중...첩 객체에서 불변성을 지켜줘야하는 경우들이 생기면서 매우 가독성이 안좋아지고, 코드를 구현하는 것이 어려워지는 상황이 발생하기도 하였다. 그래서 [immer](https://immerjs.github.io/immer/)라는 라이브러리를 통해서 좀 더 쉽게 불변객체를 유지할 수 있게 되었다. 하지만 immer를 다시 설치해주는 번거로움이 생기는 것은 당연지사였다. 그런데 createReducer에서는 `immer가 자체 내장`되어 있어서 좀 더 쉽게 리듀서를 구현할 수 있게 되었다.

- 문제2) switch-case문을 통한 구현

  일반적으로 리듀서는 switch-case문과 action.type의 문자열 관계를 기반으로 구현한다. 이 과정에서 문자열의 오타 혹은 default case를 빼먹거나 initial state를 빼먹어서 오류를 발생하는 경우가 있다. 이러한 `error-prone`(오류가 발생하기 쉬운) 구조를 벗어나기 위해서 createReducer에선 action을 핸들링하는데 있어서 2가지 패턴을 제시하였다. 1) `builder callback` 방식, 2) `map object` 방식이다. 해당 방식들에 대해선 코드를 통해서 알아보자.

  > map object 방식은 자바스크립트에서만 사용이 가능하고(타입스크립트에서는 사용 못함ㅠ), IDE에서 지원을 안하는 경우가 있어서 주로 builder callback 방식을 추천한다.

  ```js
  export const counterReducer = createReducer(initialState, (builder) => {
    builder
      .addCase(plus, (state, action) => {
        state.count++;
      })
      .addCase(minus, (state, action) => {
        state.count--;
      })
      .addDefaultCase((state, action) => {});
  });
  ```

  createReducer의 첫번째 인자로는 초기상태가 들어오고, 두번째 인자로 무엇이 들어오냐에 따라서 방식이 나뉜다. 위 코드는 `builder callback`이 들어오는 방식이다.

  builder 객체는 3가지 메소드를 제공한다. 3가지 메소드를 메소드 체이닝으로 조합하여 리듀서를 구현한다. 이로 인해 코드를 좀 더 간결하고 가독성 높게 구현할 수 있게 된다.

  - addCase(actionCreator, reducer)

    > actionCreator : string | function generated by createAction()

    > reducer : function

    특정 action type에 따른 리듀서를 구현할 때 사용한다. 주의할 점은 addCase의 경우, addMatcher, addDefaultCase 보다 먼저 구현되어 있어야한다.(쉽게 위에 구현되어야한다.)

  - addMatcher(matcher, reducer)

    > matcher : function

    > reducer : function

    여러 액션을 통합해서 그룹지을때, 사용한다. 예를 들어서 API통신시 pending상태에서의 상태변화가 모두 같다면, `(action) => action.type.endsWith('pending')` 와 같은 match 함수를 구현하여서 사용할 수 있다.

  - addDefaultCase(reducer)

    > reducer : function

    switch-case문에서의 default case에 해당하는 경우, addDefaultCase를 사용하여 구현할 수 있다. addCase와 addMatcher에서 걸러지지 않는다면 addDefaultCase가 실행된다.

  ```js
  export const counterReducer = createReducer(initialState, {
    [plus]: (state, action) => {
      state.count++;
    },
    [minus]: (state, action) => {
      state.count--;
    },
  });
  ```

  위 코드는 두번째 방식인 Map Object 방식이다. 이 방식으로 사용할 때는 createReducer에 4가지 인자가 들어갈 수 있다.

  - initialState

    초기 상태값

  - actionsMap

    액션 타입이 리듀서와 맵핑되어 있는 객체로서 일반적으로 switch-case문에서 봐왔던 방식과 유사하다.(객체로 표현한다는 점만 다를뿐). 객체로 표현하기 위해서 키값을 주어야한다. 이 때 사용하는 키값이 createAction에서 생성된 생성자 함수로서 객체에 키를 동적 할당할 수 있는 문법인 `[ ]`를 통해서 구현한다.
    (예전 방식처럼 액션 타입 문자열을 통해서 구현할 수도 있다.)

  - actionMatchers

    `[ { matcher : function, reducer : function}, ... ]` 의 형태로서 matcher에 해당하는 타입이 실행된다.

  - defaultCaseReducer

    기본 리듀서 함수로서 앞선 리듀서가 실행되지않는다면, 기본 케이스 리듀서가 실행된다.

## configureStore

## createSlice

## createAsyncThunk

## createSelector
